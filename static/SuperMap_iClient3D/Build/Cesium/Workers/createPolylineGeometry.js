define(["./when-b60132fc","./Cartesian2-47311507","./ArcType-29cf2197","./arrayRemoveDuplicates-d2f048c5","./BoundingSphere-561b54d0","./Cartographic-3309dd0d","./Color-5008547b","./ComponentDatatype-c140a87d","./Check-7b2a090c","./buildModuleUrl-3addfe33","./GeometryAttribute-3a42bbdc","./GeometryAttributes-252e9929","./IndexDatatype-8a5eead4","./Math-119be1a3","./PolylinePipeline-971d8853","./PrimitiveType-39acab88","./VertexFormat-6446fca0","./Cartesian4-3ca25aab","./RuntimeError-4a5c8994","./FeatureDetection-c3b71206","./WebGLConstants-4ae0db90","./Transforms-cb0006b0","./EllipsoidGeodesic-0f19ac62","./EllipsoidRhumbLine-ed1a6bf4","./IntersectionTests-0c6d0a14","./Plane-097b3a8f"],(function(e,t,r,a,o,i,n,l,s,p,d,c,u,y,m,f,h,v,C,_,b,A,g,w,E,P){"use strict";var T=[];function x(e,t,r,a,o){var i,l=T;l.length=o;var s=r.red,p=r.green,d=r.blue,c=r.alpha,u=a.red,y=a.green,m=a.blue,f=a.alpha;if(n.Color.equals(r,a)){for(i=0;i<o;i++)l[i]=n.Color.clone(r);return l}var h=(u-s)/o,v=(y-p)/o,C=(m-d)/o,_=(f-c)/o;for(i=0;i<o;i++)l[i]=new n.Color(s+i*h,p+i*v,d+i*C,c+i*_);return l}function D(a){var o,l,s=(a=e.defaultValue(a,e.defaultValue.EMPTY_OBJECT)).positions,d=a.colors,c=e.defaultValue(a.width,1),u=e.defaultValue(a.hMax,-1),m=e.defaultValue(a.colorsPerVertex,!1);this._positions=s,this._colors=d,this._width=c,this._hMax=u,this._colorsPerVertex=m,this._dist=a.dist,this._period=a.period,this._vertexFormat=h.VertexFormat.clone(e.defaultValue(a.vertexFormat,h.VertexFormat.DEFAULT)),this._followSurface=e.defaultValue(a.followSurface,!0),e.defined(a.followSurface)&&(o="PolylineGeometry.followSurface",l="PolylineGeometry.followSurface is deprecated and will be removed in Cesium 1.55. Use PolylineGeometry.arcType instead.",p.oneTimeWarning(o,l),a.arcType=a.followSurface?r.ArcType.GEODESIC:r.ArcType.NONE),this._arcType=e.defaultValue(a.arcType,r.ArcType.GEODESIC),this._followSurface=this._arcType!==r.ArcType.NONE,this._granularity=e.defaultValue(a.granularity,y.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=t.Ellipsoid.clone(e.defaultValue(a.ellipsoid,t.Ellipsoid.WGS84)),this._workerName="createPolylineGeometry";var f=1+s.length*i.Cartesian3.packedLength;f+=e.defined(d)?1+d.length*n.Color.packedLength:1,this.packedLength=f+t.Ellipsoid.packedLength+h.VertexFormat.packedLength+4+2}D.pack=function(r,a,o){var l;o=e.defaultValue(o,0);var s=r._positions,p=s.length;for(a[o++]=p,l=0;l<p;++l,o+=i.Cartesian3.packedLength)i.Cartesian3.pack(s[l],a,o);var d=r._colors;for(p=e.defined(d)?d.length:0,a[o++]=p,l=0;l<p;++l,o+=n.Color.packedLength)n.Color.pack(d[l],a,o);return t.Ellipsoid.pack(r._ellipsoid,a,o),o+=t.Ellipsoid.packedLength,h.VertexFormat.pack(r._vertexFormat,a,o),o+=h.VertexFormat.packedLength,a[o++]=r._width,a[o++]=r._colorsPerVertex?1:0,a[o++]=r._arcType,a[o++]=r._granularity,a[o++]=r._hMax,a[o++]=r._dist,a[o]=r._period,a};var k=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),G=new h.VertexFormat,V={positions:void 0,colors:void 0,ellipsoid:k,vertexFormat:G,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};D.unpack=function(r,a,o){var l;a=e.defaultValue(a,0);var s=r[a++],p=new Array(s);for(l=0;l<s;++l,a+=i.Cartesian3.packedLength)p[l]=i.Cartesian3.unpack(r,a);var d=(s=r[a++])>0?new Array(s):void 0;for(l=0;l<s;++l,a+=n.Color.packedLength)d[l]=n.Color.unpack(r,a);var c=t.Ellipsoid.unpack(r,a,k);a+=t.Ellipsoid.packedLength;var u=h.VertexFormat.unpack(r,a,G);a+=h.VertexFormat.packedLength;var y=r[a++],m=1===r[a++],f=r[a++],v=r[a++],C=r[a++],_=1==r[a++],b=r[a];return e.defined(o)?(o._positions=p,o._colors=d,o._ellipsoid=t.Ellipsoid.clone(c,o._ellipsoid),o._vertexFormat=h.VertexFormat.clone(u,o._vertexFormat),o._width=y,o._colorsPerVertex=m,o._arcType=f,o._granularity=v,o._hMax=C,o._dist=_,o._period=b,o):(V.positions=p,V.colors=d,V.width=y,V.colorsPerVertex=m,V.arcType=f,V.granularity=v,V.hMax=C,V.dist=_,V.period=b,new D(V))};var F=new i.Cartesian3,L=new i.Cartesian3,S=new i.Cartesian3,O=new i.Cartesian3;return D.createGeometry=function(t){var s,p,h,v=t._width,C=t._hMax,_=t._vertexFormat,b=t._colors,A=t._colorsPerVertex,g=t._arcType,w=t._granularity,E=t._ellipsoid,P=t._dist,D=t._period,k=a.arrayRemoveDuplicates(t._positions,i.Cartesian3.equalsEpsilon),G=k.length;if(!(G<2||v<=0)){if(g===r.ArcType.GEODESIC||g===r.ArcType.RHUMB){var V,M;g===r.ArcType.GEODESIC?(V=y.CesiumMath.chordLength(w,E.maximumRadius),M=m.PolylinePipeline.numberOfPoints):(V=w,M=m.PolylinePipeline.numberOfPointsRhumbLine);var I=m.PolylinePipeline.extractHeights(k,E);if(e.defined(b)){var R=1;for(s=0;s<G-1;++s)R+=M(k[s],k[s+1],V);var B=new Array(R),N=0;for(s=0;s<G-1;++s){var U=k[s],W=k[s+1],H=b[s],Y=M(U,W,V);if(A&&s<R){var q=x(0,0,H,b[s+1],Y),z=q.length;for(p=0;p<z;++p)B[N++]=q[p]}else for(p=0;p<Y;++p)B[N++]=n.Color.clone(H)}B[N]=n.Color.clone(b[b.length-1]),b=B,T.length=0}k=g===r.ArcType.GEODESIC?m.PolylinePipeline.generateCartesianArc({positions:k,minDistance:V,ellipsoid:E,height:I,hMax:C}):m.PolylinePipeline.generateCartesianRhumbArc({positions:k,granularity:V,ellipsoid:E,height:I})}var J,j=4*(G=k.length)-4,K=new Float64Array(3*j),Q=new Float64Array(3*j),X=new Float64Array(3*j),Z=new Float32Array(2*j),$=_.st?new Float32Array(2*j):void 0,ee=e.defined(b)?new Uint8Array(4*j):void 0,te=P?new Float32Array(3*j):void 0,re=0,ae=0,oe=0,ie=0,ne=0,le=0;for(p=0;p<G;++p){var se,pe;0===p?(J=F,i.Cartesian3.subtract(k[0],k[1],J),i.Cartesian3.add(k[0],J,J)):J=k[p-1],i.Cartesian3.clone(J,S),i.Cartesian3.clone(k[p],L),p===G-1?(J=F,i.Cartesian3.subtract(k[G-1],k[G-2],J),i.Cartesian3.add(k[G-1],J,J)):J=k[p+1],i.Cartesian3.clone(J,O),e.defined(ee)&&(se=0===p||A?b[p]:b[p-1],p!==G-1&&(pe=b[p]));var de=p===G-1?2:4;for(h=0===p?2:0;h<de;++h){i.Cartesian3.pack(L,K,re),i.Cartesian3.pack(S,Q,re),i.Cartesian3.pack(O,X,re),re+=3;var ce=h-2<0?-1:1,ue=h%2*2-1,ye=ue*p/G;if(Z[ae++]=C>0?ye:ue,Z[ae++]=ce*v,_.st&&($[oe++]=p/(G-1),$[oe++]=Math.max(Z[ae-2],0)),e.defined(ee)){var me=h<2?se:pe;ee[ie++]=n.Color.floatToByte(me.red),ee[ie++]=n.Color.floatToByte(me.green),ee[ie++]=n.Color.floatToByte(me.blue),ee[ie++]=n.Color.floatToByte(me.alpha)}P&&(te[3*ne]=le,ne++)}le+=i.Cartesian3.distance(J,k[p])}if(P){var fe=le,he=Math.random()*(D>0?D:fe);for(p=0;p<j;p++)te[3*p+1]=fe,te[3*p+2]=he}var ve=new c.GeometryAttributes;ve.position=new d.GeometryAttribute({componentDatatype:l.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:K}),ve.prevPosition=new d.GeometryAttribute({componentDatatype:l.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:Q}),ve.nextPosition=new d.GeometryAttribute({componentDatatype:l.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:X}),ve.expandAndWidth=new d.GeometryAttribute({componentDatatype:l.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:Z}),_.st&&(ve.st=new d.GeometryAttribute({componentDatatype:l.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:$})),e.defined(ee)&&(ve.color=new d.GeometryAttribute({componentDatatype:l.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:ee,normalize:!0})),P&&(ve.dist=new d.GeometryAttribute({componentDatatype:l.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:te}));var Ce=u.IndexDatatype.createTypedArray(j,6*G-6),_e=0,be=0,Ae=G-1;for(p=0;p<Ae;++p)Ce[be++]=_e,Ce[be++]=_e+2,Ce[be++]=_e+1,Ce[be++]=_e+1,Ce[be++]=_e+2,Ce[be++]=_e+3,_e+=4;return new d.Geometry({attributes:ve,indices:Ce,primitiveType:f.PrimitiveType.TRIANGLES,boundingSphere:o.BoundingSphere.fromPoints(k),geometryType:d.GeometryType.POLYLINES})}},function(r,a){return e.defined(a)&&(r=D.unpack(r,a)),r._ellipsoid=t.Ellipsoid.clone(r._ellipsoid),D.createGeometry(r)}}));
